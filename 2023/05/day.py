import sys  # Needed so you can run this code using: python day.py < input.txt

def solve_anything(problem, data):

    ( lambda callable: [ print ( 3 * "*" , f"part {num}:" , ( lambda do : next
    ( iter ( min ( reduce ( ( lambda float, sum : [ ( lambda sub: [ hex + sub,
    sub + bin, ] ) ( next ( iter ( ( * ( int for oct , bin , int in sum if oct
    <= hex < bin ) , len ( ( ) , ) , ) , ) ) ) for hex, bin in ( lambda clear,
    append , pop : ( id for id , * dir in ( [ ( id, dir , ) ] if not append or
    append [ len ( [ ] ) ] >= dir else ( id - id, clear . append (( id, dir ))
    or append. pop ( len ( ( ), ), ), ) if append [ len ( ( ) ) ] <= id else (
    [ id , append [ dir - dir ] ] , clear. append ( [ append [ int ( ) ] , dir
    ] , ) , ) for id , dir in pop ( clear, pop ) ) if id ) ) ( list ( reversed
    ( sorted ( ( lambda min : ( lambda tuple : [ any for any , * len in ( next
    ( iter ( enumerate ( [ tuple. append ( max ( next ( reversed ( int , ) ) ,
    tuple . pop ( ) ) ) ] ) ) ) if next ( iter ( int, ) ) <= next ( reversed (
    tuple ) ) else ( list ( tuple ) , tuple . clear ( ), tuple . extend (int),
    ) for int in min ) if any ] + [ tuple ] ) ( next ( iter ( min ,) ,) ,) ) (
    sorted ( float ) ) ) ) ) , sorted ( set ( zip for range in [ eye for *eye,
    sum in sum ] for zip in range ) ) , ( lambda push, pop : ( ( yield ( push.
    pop ( ) ) ) , ( yield from pop ( push, pop ) ) ) if push else pop ) ) ] ),
    list ( ( lambda zip : ( id for id , * dir in [ ( ( ( list ( zip ) ) , zip.
    clear ( ) ) if not globals else [ zip . clear ( ), ] if globals . endswith
    ( chr ( len ( problem ) *-~ True ) ) else [ zip. append ( * ( ( + past , +
    present ++ past , future +- past , ) for future , past, present in [ [ int
    ( object , ) for object in globals . split( ) ] , ] ) ) ] ) for globals in
    data [ -~+ True : ] + [ str ( ) , ] ] if id ) ) ( [ ] ) ) , do , ) ) ) ) )
    ( [ [ min, min + len ] for min , len in zip ( callable [ ::num ] , range )
    ] ) ) for num, range in enumerate ( ( False, ( True for map in callable ),
    callable [ True or False ::len ( str ( tuple ( ( ) , ) , ) , )] , ) , ) if
    num > False ] ) ( list ( int ( iter , ) for iter in data [ False ] . split
    ( chr ( len ( problem ) *-~+ True ) , ) [ +~ len ( [ ] ) ] . split ( ) ) )

from functools import reduce  # This was builtin in Python 2. I like builtins.

solve_anything('the correct solution of day 5', sys.stdin.read().splitlines())
